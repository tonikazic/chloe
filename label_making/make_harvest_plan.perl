#!/usr/local/bin/perl

# this is . . . /maize/demeter/data/make_harvest_plan.perl
#
# for all pollinations, determine which rows should be harvested when, 
# allowing 40 days after the last pollination in each row
#
# Kazic, 22.8.2012

# call is: perl ./make_harvest_plan.perl CROP DAYS_TO_HARVEST_DATE

# ooops, need a subroutine that tells me what to harvest today, and what its
# background is, and the color coding.  DONE.
#
# 25.8.2012


# modify harvestdoy instructions as needed for special components of the crop, such as
# popcorn, double mutants, and sibs.  Modify bag scheme as needed, too.



# if @INC already contains the path to the module, the path shouldn't be specified 
# in a use lib statement or from perl -l /path/to/module.  Otherwise Perl complains 
# it can't find the module!
#
# for some reason, command line needs the path to perl specified, even though it's 
# right at the top!  So for sure this is an issue of wierd environment variables.
#
# Kazic, 21.8.2013


# modified type selection scheme so the rows don't have to be kludged in
#
# Kazic, 23.9.2014


# to generate pdf of the output files, go to the terminal and:
# enscript FILE -o h.ps ; ps2pdf h.ps FILE.pdf ; rm h.ps


# use lib '/System/Library/Perl/Extras/5.10.0/darwin-thread-multi-2level/Date';
use Date::Calc qw(Delta_Days Add_Delta_Days Today Day_of_Year);





use lib qw(../label_making/);
use Typesetting::MaizeRegEx;
use Typesetting::DefaultOrgztn;




$crop = $ARGV[0];
$crop_str = uc($crop);
$days_out = $ARGV[1];


$today = `date`;
chomp($today);
($todayyear,$todaymonth,$todayday) = &Today;
$todaydoy = Day_of_Year($todayyear,$todaymonth,$todayday);
($year,$expharmon,$expharday) = &Add_Delta_Days($todayyear,$todaymonth,$todayday,$days_out);
$exphardoy = Day_of_Year($year,$expharmon,$expharday);



$cross_file = "../demeter/data/cross.pl";
$harvest_file = "$crop/management/rows_harvested_so_far";
$plan_file = "$crop/management/harvest_plan";
$todays_work = "$crop/management/" . $expharday . "." . $expharmon . ".harvest";



open(CRS,"<$cross_file");
open(HARV,"<$harvest_file");
open(OUT,">$plan_file");
open(TODAY,">$todays_work");



print OUT "% this is $plan_file
% generated by ../maize/crops/make_harvest_plan.perl
% on $today for crop $crop.
%
% \"date range\" is the range of days over which the row was pollinated.
% \"days to harvest\" is the difference between the nominal harvest date and today.
%
% Onion/mesh bag color-coding:
%        U = purple/red          (mutant bulking)
%        D = red/green           (double mutants)
%        @ = green/red           (bced selves)
%        S = purple/yellow       (Mo20W females)
%        W = green/yellow        (W23 females)
%        M = red/yellow          (M14 females)
%        B = white/red           (B73 females)
%        P = purple/green        (popcorn or other fun corn) \n\n\n";








while (<CRS>) {


# if a cross has been commented out, then there is an ambiguity in a parent
# that must be resolved at harvest

        if ( ( $_ =~ /$crop_str/ ) && ( $_ !~ /\%/ ) ) {


# only want ears that didn't need to be repeated
#
# make sure line begins with cross and isn't commented out
#
# Kazic, 27.9.2015

                ($ma,$pa,$date) = $_ =~ /^cross\(\'(${num_gtype_re})\',\'(${num_gtype_re})\',.+,false,.+,(${prolog_date_re})/;
                chop($date);
 

# modified type selection scheme so that rows don't have to be kludged in
# need to store a row's types, one ear at a time
# postpone evaluation of majority type until after all ears stored
#
# Kazic, 23.9.2014

# the inbreds are easy to pick off

                if ( $ma =~ /\:[SWMB]/ ) { ($cross_type,$marow,$maplant) = $ma =~ /\:(\w)?(\d{3,5})(\d{2})/; }


# now sort through inter-mutant crosses

                else {
                        ($ma_rowplant) = $ma =~ /\:0{2,4}(\d{5,6})/;
                        ($pa_rowplant) = $pa =~ /\:0{2,4}(\d{5,6})/;
                        ($marow,$maplant) = $ma_rowplant =~ /(\d{1,4})(\d{2})$/;


                        if ( $ma_rowplant eq $pa_rowplant ) { $cross_type = "@"; }

                        else {
                                ($parow) = $pa_rowplant =~ /(\d{1,4})\d{2}$/;
                                ($mafam) = $ma =~ /^\d{2}\w(\d+)\:/;
                                ($pafam) = $pa =~ /^\d{2}\w(\d+)\:/;
                                if ( ( $marow eq $parow ) || ( $mafam eq $pafam ) ) { $cross_type = "U" }
                                elsif ( $mafam ne $pafam ) { $cross_type = "D"; }
                                }
		        }



                $marow = int($marow);




                if ( ( exists $rows{$marow} ) && ( $marow ne "0" ) ) {
                        ($mindate,$maxdate,$plants,$type_so_far) = split('::',$rows{$marow});
                        if ( $date lt $mindate ) { $mindate = $date; }                         
                        if ( $date gt $maxdate ) { $maxdate = $date; }                         
                        ++$plants;




# accumulate the type of ear in each row
# types stored as string of the form type=num;
#
# I can use the variable directly in the regex, without the ${}:


                        if ( $type_so_far =~ /$cross_type/ ) {
                                ($front,$value,$back) = $type_so_far =~ /(^.*$cross_type\=)(\d+)(.*$)/;
                                ++$value;
                                $new_type_so_far = $front . $value . $back;
                                }


                        else { $new_type_so_far = $type_so_far . ";" . $cross_type . "=" . 1; }


                        $rows{$marow} = $mindate . "::" . $maxdate . "::" . $plants . "::" . $new_type_so_far;
                        }                        

                elsif ( $marow ne "0" ) { 
                        $new_type_so_far = $cross_type . "=" . 1;
                        $mindate = $date;
                        $maxdate = $date;
                        $plants = 1;
			$rows{$marow} = $mindate . "::" . $maxdate . "::" . $plants . "::" . $new_type_so_far;
                        }





#                print "$ma, $new_type_so_far, $marow, $mindate, $maxdate, $plants\n";

                $ma = "";
                $pa = "";
                $type = "";
                $type_so_far = "";
                $new_type_so_far = "";
                $cross_type = "";
                $marow = "";
                $maplant = "";
                $date = "";
                $mindate = "";
                $maxdate = "";
                $plants = "";
	        }
        }

close(CRS);





# the old version of this loop is now obsolete, since we have changed the harvesting procedure.
#
# We used to collect the harvest data in the field, so as to monitor our
# progress and enable faster crop planning.  But this is too slow now with
# hundreds of ears.  So instead, we harvest, keeping track of what rows
# were harvested when (easy with the plan) and then collect harvest data in the seed
# room.  This won't help with early planning, but it makes harvest a lot faster!
#
# We started this new harvest procedure in 13r, I just forgot.
#
# Kazic, 23.9.2014


# EXCEPT: we still need to know which rows we've harvested so far, so that the next day's
# work doesn't include rows already done.
#
# Kazic, 27.9.2014


while (<HARV>) {


        if ( ($row) = $_ =~ /^\s*(\d+)\s*$/ ) {

                $harvmarow = int($row);


                if ( ( exists $harv{$harvmarow} ) && ( $harvmarow ne "0" ) ) {
                        $harv{$harvmarow} = 1;
                        }                        

                elsif ( $harvmarow ne "0" ) { $harv{$harvmarow} = 1; }

#               print "$harvmarow $harv{$harvmarow}\n";

                $harvmarow = "";
                $row = "";
	        }
        }


close(HARV);





# now, for each distinct maxdate, compute the harvest date and compile 
# which rows and their numbers of plants should be harvested on that date.  Sort
# into row order and print out.
#
# this is the complete plan, not today's increment


foreach $marow ( sort ( keys %rows ) ) {

	($mindate,$maxdate,$plants,$type) = split(/::/,$rows{$marow});
        ($minday,$minmo,$year) = $mindate =~ /date\((\d+),(\d+),(\d+)/;
        ($maxday,$maxmo) = $maxdate =~ /date\((\d+),(\d+),/;
	


# now read the types into a hash and figure out the majority type
#
# sorting idea from Gabor Szabo [[http://perlmaven.com/how-to-sort-a-hash-in-perl]]
# this returns the key corresponding to the maximum value
#
# the trick relies on the maximum coming last in the sort, overwriting all previous
# values of $row_type


        (%type_hash) = split(/[\;=]/,$type);
        foreach my $ear_type ( sort { $type_hash{$a} <=> $type_hash{$b} } keys %type_hash ) { $row_type = $ear_type; }

	
        $range = &Delta_Days($year,$maxmo,$maxday,$year,$minmo,$minday);
     	
        ($year,$harvestmonth,$harvestday) = &Add_Delta_Days($year,$maxmo,$maxday,40);
	
        $harvestdoy = Day_of_Year($year,$harvestmonth,$harvestday);
        $info = $plants . "::" . $range . "::" . $row_type;
        $harvest{$harvestdoy}{$marow} = $info;

#        print "$marow,$row_type,$mindate,$maxdate,$plants,$range,$harvestdate\n";
	
        $harvestdate = "";
	$marow = "";
        $type = "";
        $ear_type = "";
        $row_type = "";
	$mindate = "";
	$maxdate = "";
	$plants = "";
	$minday = "";
	$maxday = "";
	$minno = "";
	$maxmo = "";
        $range = "";
	$harvestdate = "";
        $harvestmonth = "";
        $harvestday = "";
        $harvestdoy = "";
	$info = "";
        }
	





# now write the hash of hashes to OUT

$total_ears = 0;
$total_rows = 0;
$harvest_days = scalar @{[%{ $harvest{$harvestdoy} }]};
print OUT "% $harvest_days harvest days\n\n\n";

printf OUT "%s %6s %6s %6s %12s %17s %13s %13s\n" ,"harvest date","row","type","ears","date range","days to harvest","ears so far","rows so far";
print OUT "------------------------------------------------------------------------------------------------\n";


        
foreach $harvestdoy ( sort { $a <=> $b } ( keys %harvest ) ) {

        ($year,$hmonth,$hday) = Add_Delta_Days($year,1,1, $harvestdoy - 1);
        printf OUT "\n%6d.%0d\n", $hday,$hmonth;


        for $marow ( sort { $a <=> $b } keys %{ $harvest{$harvestdoy} } ) {
                $info = $harvest{$harvestdoy}{$marow};



                ($plants,$range,$row_type) = split(/::/,$info);
                $delayed = &Delta_Days($todayyear,$todaymonth,$todayday,$year,$hmonth,$hday);
                $total_ears += $plants;
                $total_rows += 1;

                printf OUT "%19s%6s%7s%10s%15s%20s\n" ,$marow,$row_type,$plants,$range,$delayed;
	        }

        printf OUT "%74d%14d\n\n",$total_ears,$total_rows;
        }



close(OUT);







# now, give us today's work: for each harvestdoy <= exphardoy, for each
# unharvested row (or incompletely harvested row), return the same
# information as above, but sorted by type of cross and row, and with the
# color coding alongside.


foreach $harvestdoy ( sort { $a <=> $b } ( keys %harvest ) ) {

	if ( $harvestdoy <= $exphardoy ) { 

                for $marow ( sort { $a <=> $b } keys %{ $harvest{$harvestdoy} } ) {

                        $info = $harvest{$harvestdoy}{$marow};
                        ($plants,$range,$row_type) = split(/::/,$info);

                        $ears_harvested = $harv{$marow};

#			print "$marow ($plants,$range,$row_type)\n";


# sometimes a pollination wasn't recorded!

                        if ( $ears_harvested <= $plants ) { 

				$colors = $bags{$row_type};
                                $diff = $harvestdoy - $exphardoy;

                                $hinfo = $plants . "::" . $colors . "::" . $diff;
				$todayswork{$row_type}{$marow} = $hinfo;

#                                print "$row_type $vmarow $diff $hinfo\n";
			        }
		        }
                }
        }









print TODAY "% this is $todays_work
% generated by ../maize/crops/make_harvest_plan.perl
% on $today for crop $crop.
%
% \"days to harvest\" is the difference between the nominal
% harvest date and the expected harvest date 
% of $expharday.$expharmon.\n\n\n";


printf TODAY "%29s %7s %6s %6s %7s\n" ,"days to","onion","mesh","total","total";
printf TODAY "%s %5s %7s %10s %6s %6s %6s %7s\n" ,"type","row","ears","harvest","bag","bag","ears","rows";
print TODAY "-----------------------------------------------------------";



$total_ears = 0;
$total_rows = 0;


foreach $row_type (@ear_order) {

        print TODAY "\n\n";

        foreach $marow ( sort { $a <=> $b } keys %{ $todayswork{$row_type} } ) {


# !exists is the negation of exists :-)

                if ( !exists $harv{$marow} ) { 

                        $hinfo = $todayswork{$row_type}{$marow};
                        ($plants,$onion,$mesh,$diff) = split(/::/,$hinfo);
                        $total_ears += $plants;
                        $total_rows += 1;
		        
#                        print "$row_type, $hinfo\n";
		        
                        printf TODAY "%2s%8s%6s%10s%11s%7s\n" ,$row_type,$marow,$plants,$diff,$onion,$mesh; 
                        }

	        }

        printf TODAY "%50d%8d\n\n",$total_ears,$total_rows;

        }


close(TODAY);
