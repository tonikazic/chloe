#!/usr/local/bin/perl

# this is . . ./maize/crops/merge_seqnd_org_packings.perl 

# a silly script to rewrite the packing_plan.org file and insert the sequenced rows from
# the prolog file.
#
# The only reason to do this is to figure out the contingency plans for when we can't
# plant the whole field . . . which, in 15r, we can't.  And this may crop up again in
# the future.  So here we go.
#
# Warning!  This bollixes the row numbers for the inbreds!
# 
# call is perl ./merge_seqnd_org_packings.perl CROP
#
# Kazic, 6.6.2015


use lib qw(../label_making/);
use Typesetting::DefaultOrgztn;
use Typesetting::MaizeRegEx;

$crop = $ARGV[0];

print `pwd`;

$today = `date`;
chomp($today);


$org_file = "$crop/planning/packing_plan.org";
$current_packing_file = "$crop/planning/packing_plan.pl";
$out_file = "$crop/planning/contingency_planting.org";



open(SEQ,"<$current_packing_file") or die "can't open $current_packing_file\n";
$i = 0;

while (<SEQ>) {
        if ( ( $_ =~ /^packing_plan\(\d+,/ ) && ( $_ !~ /\[inbred\]/ ) ) {

		my ($row,$parents,$planting) = $_ =~ /packing_plan\((\d+),\d+,\[\'(${num_gtype_re} x ${num_gtype_re})\'\],(${planting_re}),/;

		$key = $parents  . "::" . $planting;
		$seqs{$key} = $row;
#		print $key . "\n";
	        }
        }

close(SEQ);



open(ORG,"<$org_file") or die "can't open $org_file\n";
open(OUT,">$out_file") or die "can't open $out_file\n";

print OUT "% this is $out_file
% generated by ../maize/crops/merged_seqnd_org_packings.perl
% on $today for crop $crop.
%
% This file merges the contents of the $org_file with the 
% numbered rows from the $current_packing_file.  It writes out this file
% for contingency planning in the event the plantings are delayed too far
% or the planting window is far too short.
%
% To remove rows from planting, just set that block to not tangle, and
% then export the prolog.  Easy!\n\n\n";



# revised condition with second clause untested; added to preserve inbred row numbers
#
# Kazic, 7.6.2015

while (<ORG>) {
	if ( ( $_ !~ /^packing_plan\(,/ ) || ( ( $_ =~ /^packing_plan\(,/ ) && ( $_ =~ /\[inbred\]/ ) ) ) { print OUT $_; }
	     
        else {
                my ($front,$parents,$middle,$planting,$rest) = $_ =~ /^packing_plan\((,\d+,\[\')(${num_gtype_re} x ${num_gtype_re})(\'\],)(${planting_re})(.+)$/;
#                print "($front,$parents,$middle,$planting,$rest)\n";

                $this = $parents  . "::" . $planting;
		$row = $seqs{$this};
		print OUT "packing_plan(" . $row . $front . $parents . $middle . $planting . $rest. "\n";

	        }

        }



close(ORG);
close(OUT);


