#!/usr/local/bin/perl

# this is . . . /maize/demeter/data/make_harvest_plan.perl
#
# for all pollinations, determine which rows should be harvested when, 
# allowing 40 days after the last pollination in each row
#
# Kazic, 22.8.2012

# call is /usr/local/bin/perl make_harvest_plan.perl CROP DAYS_TO_HARVEST_DATE

# ooops, need a subroutine that tells me what to harvest today, and what its
# background is, and the color coding.  DONE.
#
# 25.8.2012


# modify harvestdoy instructions as needed for special components of the crop, such as
# popcorn, double mutants, and sibs.  Modify bag scheme as needed, too.



# if @INC already contains the path to the module, the path shouldn't be specified 
# in a use lib statement or from perl -l /path/to/module.  Otherwise Perl complains 
# it can't find the module!
#
# for some reason, command line needs the path to perl specified, even though it's 
# right at the top!  So for sure this is an issue of wierd environment variables.
#
# Kazic, 21.8.2013


# use lib '/System/Library/Perl/Extras/5.10.0/darwin-thread-multi-2level/Date';
use Date::Calc qw(Delta_Days Add_Delta_Days Today Day_of_Year);





use lib qw(../label_making/);
use Typesetting::MaizeRegEx;
use Typesetting::DefaultOrgztn;




$crop = $ARGV[0];
$crop_str = uc($crop);
$days_out = $ARGV[1];


$today = `date`;
chomp($today);
($todayyear,$todaymonth,$todayday) = &Today;
$todaydoy = Day_of_Year($todayyear,$todaymonth,$todayday);
($year,$expharmon,$expharday) = &Add_Delta_Days($todayyear,$todaymonth,$todayday,$days_out);
$exphardoy = Day_of_Year($year,$expharmon,$expharday);



$cross_file = "../demeter/data/cross.pl";
$harvest_file = "../demeter/data/harvest.pl";
$plan_file = "$crop/management/harvest_plan";
$todays_work = "$crop/management/" . $expharday . "." . $expharmon . ".harvest";



open(CRS,"<$cross_file");
open(HARV,"<$harvest_file");
open(OUT,">$plan_file");
open(TODAY,">$todays_work");



print OUT "% this is $plan_file
% generated by ../maize/crops/make_harvest_plan.perl
% on $today for crop $crop.
%
% \"date range\" is the range of days over which the row was pollinated.
% \"days to harvest\" is the difference between the nominal harvest date and today.
%
% Onion/mesh bag color-coding:
%        @ = green/red
%        S = purple/yellow
%        W = green/yellow
%        M = red/yellow
%        B = green/red
%        P = purple/green
%        D = red/green \n\n\n";







while (<CRS>) {


# if a cross has been commented out, then there is an ambiguity in a parent
# that must be resolved at harvest

        if ( ( $_ =~ /$crop_str/ ) && ( $_ !~ /\%/ ) ) {


# only want ears that didn't need to be repeated

                ($ma,$pa,$date) = $_ =~ /cross\(\'(${num_gtype_re})\',\'(${num_gtype_re})\',.+,false,.+,(${prolog_date_re})/;
                chop($date);
 
                ($type,$marow,$maplant) = $ma =~ /\:(\w)?(\d{3,5})(\d{2})/;
                $marow = int($marow);


                if ( ( exists $rows{$marow} ) && ( $marow ne "0" ) ) {
                        ($mindate,$maxdate,$plants) = split('::',$rows{$marow});
                        if ( $date lt $mindate ) { $mindate = $date; }                         
                        if ( $date gt $maxdate ) { $maxdate = $date; }                         
                        ++$plants;
                        $rows{$marow} = $mindate . "::" . $maxdate . "::" . $plants . "::" . $type;
                        }                        

                elsif ( $marow ne "0" ) { $rows{$marow} = $date . "::" . $date . "::" . 1 . "::" . $type; }

#                print "$ma, $type, $marow, $mindate, $maxdate, $plants\n";

                $ma = "";
                $pa = "";
                $type = "";
                $marow = "";
                $maplant = "";
                $date = "";
                $mindate = "";
                $maxdate = "";
                $plants = "";
	        }
        }

close(CRS);





# this is now obsolete, since we have changed the harvesting procedure.
#
# We used to collect the harvest data in the field, so as to monitor our
# progress and enable faster crop planning.  But this is too slow now with
# hundreds of ears.  So instead, we harvest, keeping track of what rows
# were harvested when (easy with the plan) and then collect harvest data in the seed
# room.  This won't help with early planning, but it makes harvest a lot faster!
#
# We started this new harvest procedure in 13r, I just forgot.
#
# Kazic, 23.9.2014


while (<HARV>) {

        if ( $_ =~ /$crop_str/ ) {

                ($harvma) = $_ =~ /harvest\(\'(${num_gtype_re})\',/;

                ($harvmarow) = $harvma =~ /\:\w?(\d{3,5})\d{2}/;
                $harvmarow = int($harvmarow);


                if ( ( exists $harv{$harvmarow} ) && ( $harvmarow ne "0" ) ) {
                        $ears = $harv{$harvmarow};
                        ++$ears;
                        $harv{$harvmarow} = $ears;
                        }                        

                elsif ( $harvmarow ne "0" ) { $harv{$harvmarow} = 1; }

#               print "$harvmarow $harv{$harvmarow}\n";

                $harvmarow = "";
                $ears = "";
	        }
        }


close(HARV);





# now, for each distinct maxdate, compute the harvest date and compile 
# which rows and their numbers of plants should be harvested on that date.  Sort
# into row order and print out.
#
# this is the complete plan, not today's increment


foreach $marow ( sort ( keys %rows ) ) {

	($mindate,$maxdate,$plants,$type) = split(/::/,$rows{$marow});
        ($minday,$minmo,$year) = $mindate =~ /date\((\d+),(\d+),(\d+)/;
        ($maxday,$maxmo) = $maxdate =~ /date\((\d+),(\d+),/;
	
	
        $range = &Delta_Days($year,$maxmo,$maxday,$year,$minmo,$minday);
     	
        ($year,$harvestmonth,$harvestday) = &Add_Delta_Days($year,$maxmo,$maxday,40);
	
        $harvestdoy = Day_of_Year($year,$harvestmonth,$harvestday);
        $info = $plants . "::" . $range . "::" . $type;
        $harvest{$harvestdoy}{$marow} = $info;

#        print "$marow,$mindate,$maxdate,$plants,$range,$harvestdate\n";
	
        $harvestdate = "";
	$marow = "";
        $type = "";
	$mindate = "";
	$maxdate = "";
	$plants = "";
	$minday = "";
	$maxday = "";
	$minno = "";
	$maxmo = "";
        $range = "";
	$harvestdate = "";
        $harvestmonth = "";
        $harvestday = "";
        $harvestdoy = "";
	$info = "";
        }
	





# now write out the hash of hashes to OUT

$total_ears = 0;
$total_rows = 0;
$harvest_days = scalar @{[%{ $harvest{$harvestdoy} }]};
print OUT "% $harvest_days harvest days\n\n\n";

printf OUT "%s %6s %8s %12s %17s %13s %13s\n" ,"harvest date","row","ears","date range","days to harvest","ears so far","rows so far";
print OUT "---------------------------------------------------------------------------------------\n";


        
foreach $harvestdoy ( sort { $a <=> $b } ( keys %harvest ) ) {

        ($year,$hmonth,$hday) = Add_Delta_Days($year,1,1, $harvestdoy - 1);
        printf OUT "\n%6d.%0d\n", $hday,$hmonth;


        for $marow ( sort { $a <=> $b } keys %{ $harvest{$harvestdoy} } ) {
                $info = $harvest{$harvestdoy}{$marow};


# discard third argument in this next line

                ($plants,$range) = split(/::/,$info);
                $delayed = &Delta_Days($todayyear,$todaymonth,$todayday,$year,$hmonth,$hday);
                $total_ears += $plants;
                $total_rows += 1;

                printf OUT "%19s%7s%10s%15s\n" ,$marow,$plants,$range,$delayed;
	        }

        printf OUT "%68d%14d\n\n",$total_ears,$total_rows;
        }



close(OUT);







# now, give us today's work: for each harvestdoy <= exphardoy, for each
# unharvested row (or incompletely harvested row), return the same
# information as above, but sorted by type of cross and row, and with the
# color coding alongside.


foreach $harvestdoy ( sort { $a <=> $b } ( keys %harvest ) ) {


	if ( $harvestdoy <= $exphardoy ) { 

                for $marow ( sort { $a <=> $b } keys %{ $harvest{$harvestdoy} } ) {

                        $info = $harvest{$harvestdoy}{$marow};
                        ($plants,$range,$type) = split(/::/,$info);

                        $ears_harvested = $harv{$marow};


# sometimes a pollination wasn't recorded!
#
#                        if ( $ears_harvested ne $plants ) { 

                        if ( $ears_harvested < $plants ) { 

				$colors = $bags{$type};
                                $diff = $harvestdoy - $exphardoy;



# special for bulking mutants in 13r, since in that crop they were treated as regular
# mutants:

                                if ( ( $marow >= 37 ) && ( $marow < 103 ) ) {
                                        $type = "P";
                                        $colors = "purple::green";
			  		}



# special for double mutant construction and crop improvement 

                                elsif ( ( $marow >= 103 ) && ( $marow < 139 ) ) {
                                        $type = "D";
                                        $colors = "red::yellow";
			  		}




                                $hinfo = $plants . "::" . $colors . "::" . $diff;
				$todayswork{$type}{$marow} = $hinfo;

#                                print "$type $marow $diff $hinfo\n";
			        }
		        }
                }
        }









print TODAY "% this is $todays_work
% generated by ../maize/crops/make_harvest_plan.perl
% on $today for crop $crop.
%
% \"days to harvest\" is the difference between the nominal
% harvest date and the expected harvest date 
% of $expharday.$expharmon.\n\n\n";
#
# % nb:  in 12r rows 582 -- 592 are popcorn, and get 
# % white onion bags and green mesh bags.



printf TODAY "%29s %7s %6s %6s %7s\n" ,"days to","onion","mesh","total","total";
printf TODAY "%s %5s %7s %10s %6s %6s %6s %7s\n" ,"type","row","ears","harvest","bag","bag","ears","rows";
print TODAY "-----------------------------------------------------------";



$total_ears = 0;
$total_rows = 0;


foreach $type (@ear_order) {

        print TODAY "\n\n";

        foreach $marow ( sort { $a <=> $b } keys %{ $todayswork{$type} } ) {
                $hinfo = $todayswork{$type}{$marow};
                ($plants,$onion,$mesh,$diff) = split(/::/,$hinfo);
                $total_ears += $plants;
                $total_rows += 1;

                if ( $type eq "0" ) { $easy_type = "@"; }
                else { $easy_type = $type; }


                printf TODAY "%2s%8s%6s%10s%11s%7s\n" ,$easy_type,$marow,$plants,$diff,$onion,$mesh;
	        }

        printf TODAY "%50d%8d\n\n",$total_ears,$total_rows;

        }


close(TODAY);
