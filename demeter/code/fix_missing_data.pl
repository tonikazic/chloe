% this is ../c/maize/demeter/code/fix_missing_data.pl

% a query to look for and reconstruct missing data, based on the 16r problem
% described in [[file:../porting_qui_swi.org::the-fix][porting_qui_swi.org]]
% section the-fix.
%
% Kazic, 4.5.2016


    
%declarations%


:-      module(fix_missing_data, [
                check_planted_vs_packets/2,
		find_unplanted_rows/3, 
                fix_missing_data/2,
                load_planning_file/1
                ]).


    
:-      use_module(demeter_tree('data/load_data')).
:-      use_module(demeter_tree('code/demeter_utilities')).
:-      use_module(demeter_tree('code/genetic_utilities')).

:-      ensure_loaded(demeter_tree('data/possibly_missing_data')).

    
%end%




% The code relies on two other sources of contemporaneous data to
% reconstruct database facts for a CROP that should have been collected
% at the proper time:
%
% the final ../../crops/CROP/planning/packing_plan.pl file, which
% is generated by org from the corresponding packing_plan.org file, in
% which all crop planning is done; 
%
% and
%
% the names of the eps files of barcodes in ../../barcodes/CROP/* that
% were used to generate the plant tags.  The filenames are the numerical genotype
% of the plant, for example:
%
% 16R0687:0014707.eps
%
% giving the crop (16R), family (0687), row (00147), and plant (07).  Since the
% plants are tagged after packing, planting, and counts, this is about as close
% as I can get temporally to when those data were missed.
%
%
% The barcode names were manually edited, sorted, uniqed, and prologified into the form
%
% possibly_missing_data('16R',687,r00147,'16R0687:0014701','16R0687:0014708').
%
% where the last argument is the last plant in the row.
%
%
%
% Assertions into the running copy of the database are used to keep track of
% visited facts, to avoid collisions and erroneous assignments.
% Assertions into both the top and the bottom of the database were tested and
% produce the same results with the 16r data.
%
%
% Kazic, 13.5.2018
    



    





    
% assume a newly-packed packet will have been packed within
% 60 days of planting (can we say that fast?).
%
% Kazic, 5.5.2018

    
%! fix_missing_data(+Crop:atom,+File:atom) is semidet.    

    
fix_missing_data(Crop,File) :-
        load_planning_file(Crop),    
    
        setof(Target,gather_sheep(Crop,Target),Sheep),
%        nl, nl, write_list(Sheep), nl, nl,

        bound_planting_dates(Crop,1,LowerBdPkingTS,UpperBdPkingTS),
        check_sheep(Sheep,LowerBdPkingTS,UpperBdPkingTS,LostSheep),
%        nl, nl, write_list(LostSheep), nl, nl,

        confect_sheep(Crop,LostSheep,ConfectedSheep),
        nl, nl, write_list_facts(ConfectedSheep), nl, nl,
        output_missing_data(File,LostSheep,ConfectedSheep).








% get the generated packing_plan data for that crop    

%! load_planning_file(+Crop:atom) is det.    


    
load_planning_file(Crop) :-
        downcase_atom(Crop,PathCrop),
        atomic_list_concat(['../../crops/',PathCrop,'/planning/packing_plan'],PlnngFile),
        ensure_loaded(PlnngFile).










% for a crop and planting, get reasonable upper and lower bounds for packet    
% packing
%
% Kazic, 16.5.2018

    
%! bound_planting_dates(+Crop:atom,+Planting:int,-LowerBdPkingTS:num,-UpperBdPkingTS:num) is det.

    
bound_planting_dates(Crop,Planting,LowerBdPkingTS,UpperBdPkingTS) :-    
        crop(Crop,_,_,Planting,PltngDate,_,_),
        get_timestamp(PltngDate,time(5,0,0),FirstPltngTimeStamp),
        num_secs(60,Secs),
        LowerBdPkingTS is FirstPltngTimeStamp - Secs,
        UpperBdPkingTS is FirstPltngTimeStamp + (Secs/2).
    

    


% starting with the datum pinpointing what data might be missing,
% assemble the supporting data for each datum.  Ignore inbreds, 
% elites, gerry''s, and fun corn.
%
% Note we are not asking if a mutant/8 fact exists, just that the
% plant is a mutant.
%
% Kazic, 5.5.2018


%! gather_sheep(+Crop:atom,-PaddedRow:atom-(-Ma:atom,-Pa:atom,
%!                                         +Crop:atom,
%!                                         -Family:atom,
%!                                         -FirstPlant:atom,
%!                                         -LastPlant:atom)) 
%!       is semidet.



gather_sheep(Crop,PaddedRow-(Ma,Pa,Crop,Family,FirstPlant,LastPlant)) :-    
        possibly_missing_data(Crop,Family,PaddedRow,FirstPlant,LastPlant),
        mutant_by_family(Family),
        ( genotype(Family,_,Ma,_,Pa,_,_,_,_,_,_) ->
                true
	;  
	        format('Warning! no genotype fact for family ~w planted in crop ~w~n',[Family,Crop])
        ).




    



    


% record missing data as we go along, then fix
%
% Kazic, 5.5.2018

%! check_sheep(+Sheep:list,+LowerBdPkingTS:num,
%!             +UpperBdPkingTS:num,-LostSheep:list) is semidet.


check_sheep(Sheep,LowerBdPkingTS,UpperBdPkingTS,LostSheep) :-
        check_sheep(Sheep,LowerBdPkingTS,UpperBdPkingTS,[],LostSheep).






    





    
% can have multiple rows with the same parents, but
% different packet nums
%
% can also have packets that ended up with slightly 
% different parents than planned.
% 
% Kazic, 6.5.2018



%! check_sheep(+Sheep:list,
%!                 +LowerBdPkingTS:num,+UpperBdPkingTS:num,+Acc:list,-Lost:list) is semidet.

    
    
check_sheep([],_,_,A,A).
check_sheep([PaddedRow-(Ma,Pa,Crop,Family,FirstPlant,LastPlant)|Sheep],
                 LowerBdPkingTS,UpperBdPkingTS,Acc,LostSheep) :-

        findall(Packet-PackingDate,packed_packet(Packet,Ma,Pa,_,_,PackingDate,_),Packets),

        ( Packets == [] ->
                PacketDatum = no_packet,
                PackedPackets = []
        ;

                check_dates(Packets,LowerBdPkingTS,UpperBdPkingTS,PackedPackets),
                ( PackedPackets == [] ->
                        PacketDatum = no_packet
                ;
                        ( check_packets_vs_planted(PaddedRow,Crop,Ma,Pa,LowerBdPkingTS,UpperBdPkingTS,PackedPackets) ->
                                PacketDatum = good
                        ;

                                PacketDatum = no_packet
                        )
                )
        ),


        ( planted(PaddedRow,PlntdPacket,_,_,PltngDate,PltngTime,_,Crop) ->
                ( ( PackedPackets \== [],
                    memberchk(PlntdPacket-_-_,PackedPackets) ) ->
                        PlantedDatum = good
                ;

                        ( ( closest_contemporaneous_packet(Crop,Packet,PltngDate,PltngTime,Ma,Pa),
                            Packet == PlntdPacket ) ->
                                PlantedDatum = good
                        ;
                                PlantedDatum = good
                        )
                )
	;
	        PlantedDatum = no_planted
	),  


        ( row_status(PaddedRow,_,_,_,_,_,Crop) ->
                StatusDatum = good
	;
                StatusDatum = no_status
        ),

    
        Int = [PacketDatum,PlantedDatum,StatusDatum],
        delete(Int,good,Result),
        ( Result == [] ->
                NewAcc = Acc
	;
                get_row(FirstPlant,PlntdRow),
                get_family(FirstPlant,PlntdFamily),
                append([d(Ma,Pa,Family,PackedPackets,PlntdPacket,PlntdRow,PlntdFamily,LastPlant)],Result,NewResult),
                append(Acc,[PaddedRow-NewResult],NewAcc)
        ),
        check_sheep(Sheep,LowerBdPkingTS,UpperBdPkingTS,NewAcc,LostSheep).









%! check_dates(+Packets:list,+LowerBdPkingTS:num,+UpperBdPkingTS:num,-PackedPackets:list) is semidet.



check_dates(Packets,LowerBdPkingTS,UpperBdPkingTS,PackedPackets) :-
        check_dates(Packets,LowerBdPkingTS,UpperBdPkingTS,[],PackedPackets).


check_dates([],_,_,A,A).
check_dates([Packet-PackingDate|Packets],
             LowerBdPkingTS,UpperBdPkingTS,Acc,PackedPackets) :-
        get_timestamp(PackingDate,time(5,0,0),PackingTS),
        ( ( PackingTS > UpperBdPkingTS
          ; PackingTS < LowerBdPkingTS ) ->
                NewAcc = Acc
        ;
                append(Acc,[Packet-PackingDate-PackingTS],NewAcc)
        ),
        check_dates(Packets,LowerBdPkingTS,UpperBdPkingTS,NewAcc,PackedPackets).











% did that packet get planted already?
%
% implicitly assumes an unplanted packet will be planted in the next crop,
% which may not always be true (find_closest_crop_after_packing/3).
%
% check_packets_vs_planted/7 will fail for a good packet with no planted fact
%
% oooh, feels ugly to do it this way . . . short-circuiting the recursion
% once the answer is found, and failing if no answer.
%
% Kazic, 12.5.2018



%! check_packets_vs_planted(+PaddedRow:atom,+Crop:atom,+Ma:atom,+Pa:atom,
%!            +LowerBdPkingTS:num,+UpperBdPkingTS:num,+PackedPackets:list) is det.



check_packets_vs_planted(_,_,_,_,_,_,[]) :- false.
check_packets_vs_planted(PaddedRow,Crop,Ma,Pa,LowerBdPkingTS,UpperBdPkingTS,
                                [Candidate-PackingDate-PackingTS|PackedPackets]) :-

        ( planted(PaddedRow,Candidate,_,_,_PltngDate,_PltngTime,_,Crop) ->

                ( ( PackingTS =< UpperBdPkingTS
                  ; PackingTS > LowerBdPkingTS ) ->
                        true        
                ;
                        ( packed_packet(Candidate,Ma,Pa,_,_,PackingDate,PackingTime) ->
                                find_closest_crop_after_packing(PackingDate,PackingTime,NextCrop),
                                ( NextCrop == Crop ->
                                       true
                                ;
                                       check_packets_vs_planted(PaddedRow,Crop,Ma,Pa,LowerBdPkingTS,UpperBdPkingTS,PackedPackets)
                                )
      
                        ; 
                                check_packets_vs_planted(PaddedRow,Crop,Ma,Pa,LowerBdPkingTS,UpperBdPkingTS,PackedPackets)
                        )
                )
        ;
                check_packets_vs_planted(PaddedRow,Crop,Ma,Pa,LowerBdPkingTS,UpperBdPkingTS,PackedPackets)
        ).















% now fake the missing data

%! confect_sheep(+Crop:atom,+LostSheep:list,-ConfectedSheep:list) is semidet.


confect_sheep(Crop,LostSheep,ConfectedSheep) :-
        confect_sheep(Crop,LostSheep,2000,[],Sheep),
        sort(Sheep,ConfectedSheep).


confect_sheep(_,[],_,A,A).
confect_sheep(Crop,[PaddedRow-[
                    d(Ma,Pa,Family,PossiblePackets,PlntdPacket,
                                  PlntdRow,PlntdFamily,LastPlant)|Rest]|T],
                                                                Num,Acc,Sheep) :-

        cross_parents(Ma,Pa,CrossedParents),
        ( grab_plan_for_parents(Crop,CrossedParents,PlannedRow,PlannedParents,PlannedPlntg) ->
                RealMa = Ma,
                RealPa = Pa
        ;
                remove_padding_aux(PaddedRow,IntendedRow),
                PlannedRow = IntendedRow,
                ( check_plan_for_parents_by_row(Crop,IntendedRow,Family,PlannedParents,RealMa,RealPa,PlannedPlntg) ->
                        format('Warning! relying on the genotype for row ~w~n',[PaddedRow])
                ;
                        PlannedParents = [],
                        PlannedPlntg = 1,
                        format('Warning! no good plan data for row ~w~n',[PaddedRow])
                )
        ),
        

        confect_sheep(Crop,PaddedRow,RealMa,RealPa,Family,PossiblePackets,PlntdPacket,
                      PlntdRow,PlntdFamily,PlannedRow,PlannedParents,PlannedPlntg,
                      LastPlant,Num,NextNum,Rest,Confectn),
        append(Acc,Confectn,NewAcc),
        confect_sheep(Crop,T,NextNum,NewAcc,Sheep).












% nb: if two rows have been planted with the same parents but at two
% different plantings, the second planting is not likely to be returned.
% A bug, but a small one.
%
% Kazic, 10.5.2018


%! grab_plan_for_parents(+Crop:atom,+CrossedParents:atom,
%!           -PlannedRow:int,-PlannedParents:list,-PlannedPlntg:int) is semidet.


grab_plan_for_parents(Crop,CrossedParents,PlannedRow,PlannedParents,PlannedPlntg) :-
        packing_plan(PlannedRow,_,PlannedParents,PlannedPlntg,_,_,_,Crop,_,_),
        memberchk(CrossedParents,PlannedParents).












%! check_plan_for_parents_by_row(+Crop:atom,+IntendedRow:int,+Family:int,
%!              -PlannedParents:list,-Ma:atom,-Pa:atom,-PlannedPlntg:int) is semidet.


check_plan_for_parents_by_row(Crop,IntendedRow,Family,PlannedParents,Ma,Pa,PlannedPlntg) :-
        packing_plan(IntendedRow,_,IntendedParents,PlannedPlntg,_,_,_,Crop,_,_),
        genotype(Family,MaFam,Ma,PaFam,Pa,_,_,_,_,_,_),
        convert_parental_syntax(IntendedParents,ParentalGtypes),
        ( memberchk((Ma,Pa),ParentalGtypes) ->
                PlannedParents = IntendedParents
        ;
                get_parental_families(ParentalGtypes,ParentalFamilies),
                ( memberchk((MaFam,PaFam),ParentalFamilies) ->
                        cross_parents(Ma,Pa,Crossed),
                        PlannedParents = [Crossed]
                ;
                        PlannedParents = []
                )
        ).














% set the time to midnight because I never pack or plant that late!
% So a signal for the invented data!
%
% Information is grouped by row, so the planted/8 fact can safely use
% the current value for PacketNum.  PacketNum is incremented in the first
% clause only.
%
% Kazic, 5.5.2018



% we can have a perfectly good packet that is rejected because
% there is no planted fact in check_packets_vs_planted/7.
%
% So to keep track of packets, rows, and row statuses that we have already
% visited (by generating them), we assert them into the database, ensuring they
% will be found first.  This is a temporary assertion:  the confected facts
% will be manually inserted after checking into their appropriate files.
%
% Kazic, 12.5.2018



%! confect_sheep(+Crop:atom,+PaddedRow:atom,+Ma:atom,+Pa:atom,+Family:atom,+RemPackets,+PlntdPacket:atom,
%!               +PlntdRow:atom,+PlntdFamily:int,+PlannedRow:int,+PlannedParents:list,+PlannedPlntg:int,
%!               +LastPlant:atom,+NextNum:int,-LastNum:int,+ToConfect:list,-Confectns:list)
%!  is semidet.



confect_sheep(_,_,_,_,_,_,_,_,_,_,_,_,_,N,N,[],[]).
confect_sheep(Crop,PaddedRow,Ma,Pa,Family,PossiblePackets,PlntdPacket,
                   PlntdRow,PlntdFamily,PlannedRow,PlannedParents,PlannedPlntg,
                                LastPlant,Num,LastNum,[H|T],[Confectn|Confectns]) :-

        
        estimate_seed(PaddedRow,Crop,Seed),
        crop(Crop,_,_,PlannedPlntg,PlntgDate,_,_),


        ( H == no_packet ->


% always prefer the actual planted packet to packet data gathered from
% packed_packets.  The reason is that rows planted with the same parents at different
% plantings in the same crop may have packed_packet facts, just not the one corresponding
% to this row.  So a selectchk for the planted packet out of PossiblePackets can
% fail.
%
% Kazic, 12.5.2018

                ( nonvar(PlntdPacket) ->
                        Confectn = packed_packet(PlntdPacket,Ma,Pa,Seed,faked,PlntgDate,time(00,00,00)),
                        NextNum = Num,
                        RemPackets = []

                ;


% see stub below

                        pad(Num,5,Padded),
                        atom_concat(p,Padded,PacketNum),
                        Confectn = packed_packet(PacketNum,Ma,Pa,Seed,faked,PlntgDate,time(00,00,00)),
                        NextNum is Num + 1,
                        RemPackets = PossiblePackets
                )

        ;

                ( H == no_planted ->

                        ( mutant_by_family(Family) ->
                                Ft = 10
                        ;
                                Ft = 20
                        ),



% we''re going to use the row from the tag, but a series
% of checks first


                        ( var(PlntdRow) ->
                                ( var(PlannedRow) ->
                                        format('Warning! no record of row ~w planted, using row from tag~n',[PaddedRow])
                                ;
                                        build_row(PlannedRow,PaddedPlannedRow),
                                        ( PaddedPlannedRow \== PaddedRow ->
                                                format('Warning! planted row ~w differs from planned row ~w, using row from tag~n',[PaddedRow,PaddedPlannedRow])
                                        ;
                                                true
                                        )
                                )
                        ;
                                build_row(PlntdRow,PaddedPlntdRow),
                                ( PaddedPlntdRow \== PaddedRow ->                                                                                    format('Warning! planted row ~w does not match row ~w from tag, using row from tag for row ~w~n',[PaddedPlntdRow,PaddedRow])                    
                                ;
                                        true
                                )
                        ),



                        get_timestamp(PlntgDate,time(0,0,0),PlntgTimeStamp),
                        ( closest_contemporaneous_packet_by_crop(Crop,Ma,Pa,PlntgTimeStamp,Packet,_) ->
                                true
                        ;
                                packed_packet(Packet,Ma,Pa,_,faked,_,_)
                        ),
                        \+ planted(PaddedRow,Packet,_,_,PlntgDate,_,_,Crop),
                        Confectn = planted(PaddedRow,Packet,Ft,faked,PlntgDate,time(0,0,0),full,Crop),
                        NextNum = Num,
                        RemPackets = PossiblePackets

                ;


% this case untested so far
%
% Kazic, 13.5.2018

                        H == no_status,
                        get_plant(LastPlant,Plant),
                        atom_number(Plant,NumPlants),
                        find_std_count_dates_same_planting(Crop,PlntgDate,PaddedRow,EvaluatnDate),

                        Confectn = row_status(PaddedRow,num_emerged(NumPlants),[phenotype(faked,NumPlants)],faked,EvaluatnDate,time(0:00:00),Crop),
                        NextNum = Num,
                        RemPackets = PossiblePackets
                )
        ),



% both asserta and assertz give the same results with the 16r data;
% prefer asserta for speed.  Note that reloading the saved version of the database
% will effectively abolish these assertions: the facts must be incorporated
% into their proper files.
%
% Kazic, 13.5.2018

        asserta(load_data:Confectn),

        confect_sheep(Crop,PaddedRow,Ma,Pa,Family,RemPackets,PlntdPacket,
                                PlntdRow,PlntdFamily,PlannedRow,PlannedParents,PlannedPlntg,
                                   LastPlant,NextNum,LastNum,T,Confectns).









% get the date on which the stands of the neighboring rows were counted

%! find_std_count_dates_same_planting(+Crop:atom,+PlntgDate:term,
%!                             +PaddedRow:atom,-EvaluatnDate:term) is det?


find_std_count_dates_same_planting(Crop,PlntgDate,PaddedRow,EvaluatnDate) :-
        setof(Row-StatusDate,row_planted_same_day(Crop,PlntgDate,Row,StatusDate),StandCnt),
        arg(1,StandCnt,LowerBd-_),
        last(StandCnt,UpperBd-_),
        find_bracketing_rows(PaddedRow,LowerBd,UpperBd,StandCnt,LowerRow,UpperRow),
        group_pairs_by_key(StandCnt,RowEvaluatns),
        selectchk(LowerRow-LowerDates,RowEvaluatns,Rest),
        selectchk(UpperRow-UpperDates,Rest,_),
        union(LowerDates,UpperDates,EvaluatnDates),
        max_member(EvaluatnDates,EvaluatnDate).









%! row_planted_same_day(+Crop:atom,+PlntgDate:term,-Row:atom,-StatusDate:term) is semidet.

row_planted_same_day(Crop,PlntgDate,Row,StatusDate) :-
        planted(Row,_,_,_,PlntgDate,_,_,Crop),
        row_status(Row,_,_,_,StatusDate,_,Crop).
      














%! find_bracketing_rows(+PaddedRow:atom,+LowerBd:num,+UpperBd:num,
%!                  +StandCnt:list,-LowerRow:atom,-UpperRow:atom) is semidet.


find_bracketing_rows(PaddedRow,LowerBd,UpperBd,StandCnt,LowerRow,UpperRow) :-
        find_bracketing_rows(PaddedRow,StandCnt,LowerBd,LowerRow,UpperBd,UpperRow).



find_bracketing_rows(_,[],L,L,U,U).
find_bracketing_rows(PaddedRow,[Row-_|T],PriorLowerRow,LowerRow,PriorUpperRow,UpperRow) :-
        ( ( Row @< PaddedRow,
            Row @> PriorLowerRow ) ->
                NewLowerRow = Row,
                NewUpperRow = PriorUpperRow
        ;
                ( ( Row @> PaddedRow,
                    Row @< PriorUpperRow ) ->
                        NewLowerRow = PriorLowerRow,
                        NewUpperRow = Row
                ;
                        NewLowerRow = PriorLowerRow,
                        NewUpperRow = PriorUpperRow
                )
        ),
        find_bracketing_row(PaddedRow,T,NewLowerRow,LowerRow,NewUpperRow,UpperRow).













% integrate with the other output_data predicates once
% my desires here have stabilized
%
% Kazic, 7.5.2018

%! output_missing_data(+File:atom,+LostSheep:list,+ConfectedSheep:list) is det.


output_missing_data(File,LostSheep,ConfectedSheep) :-
        get_time(TimeStamp),
        stamp_date_time(TimeStamp,Now,local),
        stamp_date_time(TimeStamp,UTCNow,'UTC'),
        nice_date(Now,NiceNow),
        format_time(atom(NiceUTCNow),'%b %d, %T %Z',UTCNow),
        open(File,write,Stream),
        format(Stream,'% this is ../c/maize/demeter/data/~w.pl~n~n',[File]),
        format(Stream,'% computed by fix_missing_data:fix_missing_data/2 on ~w (= ~w)~n~n~n',[NiceNow,NiceUTCNow]),
        format(Stream,'% list of missing facts~n~n',[]),
        write_list_facts(Stream,LostSheep),
        format(Stream,'~n~n% list of proposed facts~n~n',[]),
        write_list_facts(Stream,ConfectedSheep),
        close(Stream).








%%%%%%%%%%% spot checks %%%%%%%%%%%%%%%%
%
%
% some of this is probably already in crop_managment.pl, but
% that hasn''t been ported yet.
%
% Kazic, 13.5.2018


%! check_planted_vs_packets(+Crop:atom,-MissingPackets:list) is semidet.

check_planted_vs_packets(Crop,MissingPackets) :-
        crop(Crop,_,_,1,PltngDate,_,_),
        get_timestamp(PltngDate,time(5,0,0),FirstPltngTimeStamp),
        num_secs(60,Secs),
        LowerBdPkingTS is FirstPltngTimeStamp - Secs,
        UpperBdPkingTS is FirstPltngTimeStamp + (Secs/2),
        findall(PRow-Packet,planted(PRow,Packet,_,_,_Date,_,_,Crop),PlantedRows),
        check_planted_vs_packets(Crop,LowerBdPkingTS,UpperBdPkingTS,PlantedRows,MissingPackets).







%! find_unplanted_rows(+Crop:atom,-PlantedRows:list,-Unplanted:list) is semidet.

find_unplanted_rows(Crop,PlantedRows,Unplanted) :-
        findall(PRow,planted(PRow,_P,_F,_O,_D,_T,_L,Crop),PlantedRows),
        remove_padding_list(PlantedRows,Stripped),
        sort(Stripped,Sorted),
        find_unplanted_rows_aux(Sorted,[],Unplanted).







find_unplanted_rows_aux([],A,A).
find_unplanted_rows_aux([Penult,Last],Acc,Unplanted) :-
        ( Last is Penult + 1 ->
                NewAcc = Acc
        ;
                append(Acc,[gap(Penult,Last)],NewAcc)
        ),
        find_unplanted_rows_aux([],NewAcc,Unplanted).



find_unplanted_rows_aux([RowNum,Next|T],Acc,Unplanted) :-
        ( Next is RowNum + 1 ->
                NewAcc = Acc
        ;
                append(Acc,[gap(RowNum,Next)],NewAcc)
        ),
        find_unplanted_rows_aux([Next|T],NewAcc,Unplanted).










% stopped here; test



%! check_planted_vs_packets(+Crop:atom,+LowerBdPkingTS:num,
%!            +UpperBdPkingTS:num,+PlantedRows:list,-Missing:list) is semidet.

check_planted_vs_packets(Crop,LowerBdPkingTS,UpperBdPkingTS,PlantedRows,Missing) :-
        check_planted_vs_packets(Crop,LowerBdPkingTS,UpperBdPkingTS,PlantedRows,[],Missing).






check_planted_vs_packets(_,_,_,[],A,A).
check_planted_vs_packets(Crop,LowerBdPkingTS,UpperBdPkingTS,
                          [PRow-Packet|PlantedRows],Acc,Missing) :-
        ( ( packed_packet(Packet,_Ma,_Pa,_,_,PkingDate,_),
            check_dates([Packet-PkingDate],LowerBdPkingTS,UpperBdPkingTS,[],OK),
            OK \== [] ) ->
                NewAcc = Acc
        ;
                remove_padding(PRow,Row),
                packing_plan(Row,_,PlannedParents,_,_,_,_,Crop,_,_),
                convert_parental_syntax(PlannedParents,TupleParents),
                check_tuple_parents(LowerBdPkingTS,UpperBdPkingTS,TupleParents,GoodCandidates),
                ( GoodCandidates \== [] ->
                        NewAcc = Acc
                ;
                        append(Acc,[PRow-Packet],NewAcc)
                )
        ),
        check_planted_vs_packets(Crop,LowerBdPkingTS,UpperBdPkingTS,PlantedRows,NewAcc,Missing).






check_tuple_parents(LowerBdPkingTS,UpperBdPkingTS,Parents,GoodCandidates):-
        check_tuple_parents(LowerBdPkingTS,UpperBdPkingTS,Parents,[],GoodCandidates).


check_tuple_parents(_,_,[],A,A).
check_tuple_parents(LowerBdPkingTS,UpperBdPkingTS,[(Ma,Pa)|T],Acc,GoodCandidates) :-
        ( packed_packet(Maybe,Ma,Pa,_,_,MaybePkingDate,_) ->
                check_dates([Maybe-MaybePkingDate],LowerBdPkingTS,UpperBdPkingTS,[],OK),
                ( OK \== [] ->
                        append(Acc,[(Ma,Pa)],NewAcc)
                ;
                        NewAcc = Acc
                )
        ;
                NewAcc = Acc
        ),
        check_tuple_parents(LowerBdPkingTS,UpperBdPkingTS,T,NewAcc,GoodCandidates).










% supply missing genotypes that were not computed in the regular way.

supply_missing_genotypes(Crop,Genotypes,File) :-
        ensure_loaded(demeter_tree('data/missing_genotypes')),
        missing_genotypes(Crop,Families),
        load_planning_file(Crop),
        match_families(Crop,Families,DupedGenotypes,Failures),
        list_to_set(DupedGenotypes,Genotypes),
        output_data(File,bar,Genotypes),
        write_list(Failures).











% I mistrust this predicate since it can''t find an existing genotype fact
% for row 72 in 17R.
%
% The problem may be we are proceeding from families, rather than rows or packets.
%
% Kazic, 16.5.2018


match_families(Crop,Families,Genotypes,Failures) :-
        match_families(Crop,Families,[],Genotypes,[],Failures).



% if the same family is planted in multiple rows, then we get duplicate
% genotype facts.

match_families(_,[],A,A,B,B).
match_families(Crop,[Family|Families],Acc,Genotypes,FailAcc,Failures) :-
        ( genotype(Family,_,_,_,_,_,_,_,_,_,_) ->
                NewAcc = Acc,
                NewFailAcc = FailAcc
        ;

                possibly_missing_data(Crop,Family,PaddedRow,_,_),
                remove_padding(PaddedRow,Row),
                packing_plan(Row,_,PossibleParents,Plntg,_,_,_K,Crop,_Seed,_Ft),
                convert_parental_syntax(PossibleParents,TupleParents),
                bound_planting_dates(Crop,Plntg,LowerBdPkingTS,UpperBdPkingTS),
                all_possible_parental_packets(Crop,TupleParents,PaddedRow,LowerBdPkingTS,UpperBdPkingTS,LikelyPackets),
                ( LikelyPackets == [] ->
                         format('Warning! no good candidates found for row ~w of crop ~w planted with family ~w~n',[PaddedRow,Crop,Family]),
                         append(FailAcc,[PaddedRow-Family],NewFailAcc),
                         NewAcc = Acc
                ;
                         generate_fgenotypes(Family,LikelyPackets,FGenotypes),
                         NewFailAcc = FailAcc,
                         append(Acc,FGenotypes,NewAcc)
                )
        ),

        match_families(Crop,Families,NewAcc,Genotypes,NewFailAcc,Failures).












all_possible_parental_packets(Crop,TupleParents,PaddedRow,LowerBdPkingTS,UpperBdPkingTS,LikelyPackets) :-
        all_possible_parental_packets_aux(Crop,TupleParents,PaddedRow,LowerBdPkingTS,UpperBdPkingTS,Candidates),
        flatten(Candidates,LikelyPackets).



all_possible_parental_packets_aux(_,[],_,_,_,[]).
all_possible_parental_packets_aux(Crop,[(Ma,Pa)|TupleParents],PaddedRow,
                             LowerBdPkingTS,UpperBdPkingTS,[Packets|Candidates]) :-
        findall((Ma,Pa,Date),(packed_packet(_Packet,Ma,Pa,_,_,Date,Time),
                                get_timestamp(Date,Time,PkingTS),
                                PkingTS >= LowerBdPkingTS,
                                PkingTS =< UpperBdPkingTS),Packets),
%                                planted(PaddedRow,Packet,_,_,_,_,_,Crop)),Packets),
        all_possible_parental_packets_aux(Crop,TupleParents,PaddedRow,
                             LowerBdPkingTS,UpperBdPkingTS,Candidates).










generate_fgenotypes(_,[],[]).
generate_fgenotypes(Family,[(Ma,Pa,_)|LikelyPackets],
                   [fgenotype(Family,MaFam,Ma,PaFam,Pa,MaGma,MaMut,PaGma,PaMut,[PaMut],K)|FGenotypes]) :-
        get_family(Ma,MaFam),
        get_family(Pa,PaFam),
        genotype(MaFam,_,_,_,_,MaGma,_,_,MaMut,_,_),
        genotype(PaFam,_,_,_,_,PaGma,_,_,PaMut,_,K),
        generate_fgenotypes(Family,LikelyPackets,FGenotypes).
























%%%%%%%%%%%%%% obsolete stub %%%%%%%%%%%%%%%%%
%
% in the end, a simpler approach seemed sufficient --- this was feeling very
% rococo --- but I''ve preserved it here just in case.
%
% Kazic, 13.5.2018



% % if PossiblePackets \== [], selectchk a packet and use the remainder in the next call
% %
% % but two problems --- if check_parents fails on the possible packets, don''t want to use
% % them; and if a packet from that list is used, want to remove it from possible packets in
% % subsequent turns of the recursion
%
%
%                         ( PossiblePackets \== [] ->
%                                 min_member(PossPacket-_,PossiblePackets),
%                                 selectchk(PossPacket-_,PossiblePackets,RemPackets),
%                                 Confectn = packed_packet(PossPacket,Ma,Pa,Seed,faked,PlntgDate,time(00,00,00))
%
%                         ),
%
%
%
%
%                         ( check_parents(Ma,Pa,PossiblePackets,Family,PlntdFamily,Packet,PackingDate) ->
%                                 true
%                         ;
%                                 check_parents(Ma,Pa,PlannedParents,Family,PlntdFamily,Packet,PackingDate)
%                         ),


