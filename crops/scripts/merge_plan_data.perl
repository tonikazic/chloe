#!/opt/perl5/perls/perl-5.26.1/bin/perl


# this is ../c/maize/crops/scripts/merge_plan_data.perl
#
# This script implements two successive operations:
#
#        merging old plans into a new packing_plan.org file; and
#        sequencing the row numbers in the final packing_plan.prolog file,
#                 generated by org mode from the packing_plan.org file.
#
#
#
#
# Operation merge:
#
# Given the final plan.pl and packing_plan.org files for a previous crop,
# substitute the planting, plan, and comments facts from the plan.pl into the
# packing_plan.org (since the plan.pl are revised during scoring), and
# put these revised facts in a new packing_plan.org
# file for the current crop.  Remove sequence numbers as we go.
#
# The new packing_plan.org file can then be edited freely, for example
# removing rows that are unimportant for the current crop.
#
#
#
# Operation sequence:
#
# From the final packing_plan.org file, output the prolog code blocks using the
# org export function.  This file, packing_plan.prolog, is the input for the sequence
# operation.
#
# Given a new packing_plan.pl file without sequence numbers, rewrite with 
# sequence numbers.
#
# Kazic, 11.7.2018



# call is merge_plan_data.perl TASK CURRENT_CROP PRIOR_CROP
#
# where task is one of {merge,sequence}; *CROPs are the numbers of the current and prior crops.
#
# PRIOR_CROP is required only for the merge operation, 
# but omitting it when using the sequence operation 
# triggers an uninstantiated variable warning.  
#
# Both CROPs are lower-case, e.g., 12n.





# both the packing_plan.pl format and (apparently) the planting_re 
# had changed since this was written.  
# Modified code so it all works again.
#
# Most importantly, last year I switched to doing the planning in org mode.
# The comments and section headers are invaluable. So changed the input
# plan file to the packing_plan.org file this year.
#
# Kazic, 21.4.2015




use strict;
use warnings;

use Cwd 'getcwd';


use lib '../../label_making/Typesetting/';
use DefaultOrgztn;
use MaizeRegEx;




my $operation = $ARGV[0];
my $current_crop = $ARGV[1];
my $prior_crop = $ARGV[2];
my $crop_str = uc($prior_crop);
my $current_crop_string = uc($current_crop);



my $local_dir = getcwd;
my ($dir) = &adjust_paths($current_crop,$local_dir);


my $cl;
my %plans;

if ( $current_crop =~ /\d+[rR]/ ) { $cl = 15; }
elsif ( $current_crop =~ /\d+[nN]/ ) { $cl = 13; }
else { $cl = 10; }



my $today = `date`;
chomp($today);





# pre-15r
#
# $prior_packing_file = "$prior_crop/planning/packing_plan.pl";
# $current_packing_file = "$current_crop/planning/packing_plan.pl";

# 15r and later


my $prior_packing_file = $dir . $planning_root . "packing_plan.org";
$prior_packing_file =~ s/$current_crop/$prior_crop/;
my $plan_file = $demeter_dir . "plan.pl";
my $current_packing_file = $dir . $planning_root . "packing_plan.org";
my $prolog_packing_file = $dir . $planning_root . "packing_plan.prolog";
my $numbered_packing_file = $dir . $planning_root . "sequenced.packing_plan.pl";



# print "ppf: $prior_packing_file\npf: $plan_file\ncpf: $current_packing_file\nprpf: $prolog_packing_file\nnpf: $numbered_packing_file\n";







if ( $operation eq "merge" ) {

        open my $prior_fh, '<', $prior_packing_file or die "sorry, can't open input file $prior_packing_file\n";
        open my $plan_fh, '<', $plan_file or die "sorry, can't open input file $plan_file\n";
        open my $out, '>', $current_packing_file or die "sorry, can't open output file $current_packing_file\n";
 
    


        print $out "% this is $current_packing_file
% generated by ../maize/crops/merge_plan_data.perl
% on $today for crop $current_crop.
%
% The most recent plan data are derived from $plan_file for the $prior_crop.  These
% are substituted into the packing_plan.pl data for $prior_crop to generate
% packing_plan/10 facts that are in the previous sequence, but not numbered.
%
% Wait until all packing_plan/10 facts are written, and in the correct sequence,
% before re-running the script to insert the sequence numbers for planting!\n\n\n";



        while (<$plan_fh>) {

                if ( ( $_ =~ /\'$crop_str\'\)./ ) 
                     && ( $_ !~ /^\%/ )  
                     && ( $_ !~ /\[gerry\]/ ) && ( $_ !~ /\[inbred\]/ ) ) {


                        my ($ma,$pa,$planting,$plan,$comment) = $_ =~ /plan\(\'(${num_gtype_re})\',\'(${num_gtype_re})\',(${planting_re}),(\[${plan_re}\]),(\'${notes_re}\')/;

#                        print "$_ $ma,$pa,$planting,$plan,$comment)\n";

                        if ( $ma eq "" ) { print "empty ma: $_ ($ma,$pa,$planting,$plan,$comment)\n"; }

                        $plans{$ma} = $pa . "::" . $planting . "::" .  $plan . "::" .  $comment;
                        }
	        }




#                if ( ( $_ =~ /[\*\w\%\#]+/ ) 


	
        while (<$prior_fh>) {
                if ( $_ !~ /^packing_plan/ ) { print $out $_; }
                else {

#                        my ($packets,$pma,$ppa,$K) = $_ =~ /\(\d+,(${planting_re}),\[\'(${num_gtype_re}) x (${num_gtype_re})\'\],.+,\'(${knum_re})\',\'${crop_re}\',\d+,\d+\)/;
#
# oops, packing_plan.pl no longer has row numbers as first argument! and some other things have changed.
#
# Kazic, 21.4.2015

                        if ( $_ !~ /\[gerry\]/ ) { 


                                my ($packets,$pma,$ppa,$K) = $_ =~ /\(,(${planting_re}),\[\'(${num_gtype_re}) x (${num_gtype_re})\'\],\d,.+,\'(${knum_re})/; 




# kinda handy not to have to cut and paste the inbred lines
#
# Kazic, 21.4.2015

                                if ( $_ =~ /\[inbred\]/ ) { print $out $_; }


                                elsif ( exists $plans{$pma} ) {
                                        my ($pa,$planting,$plan,$comment) = split("::",$plans{$pma});

                                        if ( $pa ne $ppa ) { print "Warning! males $pa and $ppa do not match for ear $pma!\n"; }

                                        else { print $out "packing_plan(,$packets,['$pma x $pa'],$planting,$plan,$comment,'$K',$cl,10).\n"; }
				        }
			        }
		        }
	        }
        }










# finished!
#
# Kazic, 5.6.2014


elsif ( $operation eq "sequence" ) {

        open my $cur_fh, '<', $prolog_packing_file or die "sorry, can't open input file $prolog_packing_file\n";
        open my $out, '>', $numbered_packing_file or die "sorry, can't open output file $numbered_packing_file\n";


    
        print $out "% this is $numbered_packing_file\n% generated by ../maize/crops/merge_plan_data.perl using operation sequence \n% on $today for crop $current_crop.\n\n\n";

        my $i = 1;

        while (<$cur_fh>) {

                if ( $_ =~ /^packing_plan/ ) {
                        my ($front,$middle,$end) = $_ =~ /^(packing_plan\()(,.+)(,\d{1,2},\d{1,2}\).)$/;
#                        print "$i $front $middle $end\n";
                        print $out $front . $i . $middle . ",'" . $current_crop_string . "'" . $end . "\n";
                        $i++;
                        }


                else { print $out $_; }
	        }
        }
