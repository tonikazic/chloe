#!/usr/bin/perl

# this is . . . /maize/demeter/data/check_row_assignments.perl
#
# I want an independent way to check the results of the Prolog-generated field book,
# just in case errors are introduced by back-tracking.
#
# Kazic, 9.7.2012

# call is check_row_assignments.perl START_ROW END_ROW YEAR CROP
#
# where rows are in fully padded form (r00...), year is the four digit year,
# and crop is the upper-case crop (e.g., 12R).

# still has problems clearing variables for family numbers!
# FIX!
#
# Kazic, 24.9.2012


use lib qw(../label_making/);
use Typesetting::MaizeRegEx;


# the code emulates the following grep commands very directly:
#
# grep r00142 planted.pl | grep 2012
#    planted(r00142,p00600,20,wade,date(18,05,2012),time(16,12,37),full,'12R').
#
# grep p00600 packed_packet.pl | grep 2012
#    packed_packet(p00600,'10R205:S0002302','10R2252:0031702',20,toni,date(30,04,2012),time(11,0,0)).
#
# grep 10R205:S0002302 genotype.pl
#    genotype(3270,205,'10R205:S0002302',2252,'10R2252:0031702','Mo20W','Mo20W','W23','Les15-N2007',['Les15-N2007'],'K6711').
#
# grep 10R205:S0002302 plan.pl | grep 12R
#    plan('10R205:S0002302','10R2252:0031702',0,['S'],'is 2nd; very slow, dwarf','12R').
#    plan('10R205:S0002302','10R2252:0031702',1,['S'],'is 2nd; very slow, dwarf','12R').


$start_row = $ARGV[0];
$end_row = $ARGV[1];
$year = $ARGV[2];
$crop = $ARGV[3];
$planted_file = "../demeter/data/planted.pl";
$packet_file = "../demeter/data/packed_packet.pl";
$genotype_file = "../demeter/data/genotype.pl";
$plan_file = "../demeter/data/plan.pl";
$crop_file = "../demeter/data/crop.pl";

$results_file = "$crop/management/assignment_results";
$warnings_file = "$crop/management/assignment_warnings";
$row_plan_file = "$crop/management/assignment_row_plan.csv";

(@row_array) = &make_row_array($start_row,$end_row);

(%plantings) = &make_plantings_hash($crop,$crop_file);

$today = `date`;
chomp($today);

open(RES,">$results_file");
open(WARN,">$warnings_file");
open(PLAN,">$row_plan_file");



print RES "% this is $results_file generated by ../maize/demeter/data/check_row_assignments.perl
% on $today for rows $start_row -- $end_row of crop $crop in the year $year.\n
% Compare to the field book generated by Prolog.\n\n\n";

print WARN "% this is $warnings_file generated by ../maize/demeter/data/check_row_assignments.perl
% on $today for rows $start_row -- $end_row of crop $crop in the year $year.\n
% Make sure we understand why these warnings are generated and fix any data necessary.\n\n\n";

print WARN "% this is $row_plan_file generated by ../maize/demeter/data/check_row_assignments.perl
% on $today for rows $start_row -- $end_row of crop $crop in the year $year.\n
% This is the plan for each row per the current version of plan.pl, without considering pollinations already done.\n\n\n";


foreach $row (@row_array) { 

         $plline = `grep $row $planted_file | grep $crop | grep -v '%'`;

         if ( $plline ne "" ) {

                  ($packet,$date) = $plline =~ /,(${pure_packet_re}),.+,(${prolog_date_re}),/;


                  if ( exists $plantings{$date} ) { $planted_plntg_num = $plantings{$date}; }
                  else { print WARN "Warning! planting date for row $row not found in the crop fact!\n"; }


                  $ppline = `grep $packet $packet_file | grep $year | grep -v '%'`; 
                  if ( $ppline ne "" ) {
        
                          ($ma,$pa) = $ppline =~ /,\'(${num_gtype_re})\',\'(${num_gtype_re})\',/;
	 	 
                          if ( ( $ma ne "" ) && ( $pa ne "" ) ) {
                                  $maline = `grep $ma $genotype_file | grep -v '%'`;
                                  $match_index = index($maline, $pa);
                                  if ( $match_index != -1 ) {
                                          ($family) = $maline =~/genotype\((\d+),/;
	 	 		          ($tmp) = $maline =~ /$ma\',\d+,\'$pa\',(.+)\)\./;
                                          ($genotype,$knum) = $tmp =~ /(.+),\[.+\],\'(\w*)\'/;
                                          $genotype =~ s/\'//g;
                                          $genotype = "(" . $genotype . ")";
	 	 	                  }
	 	 
                                  else { print WARN "Warning!  genotype fact for $ma doesn't contain $pa, index is $match_index!\n"; }
	 	 
	 	 
	 	                  $planline = `grep $ma $plan_file | grep $crop | grep -v '%'`;
                                  if ( index($planline, $pa) != -1 ) {
	 	                         ($planned_plntg_num,$plan,$comment) = $planline =~ /\'$ma\',\'$pa\',(\d),(\[.+\]),\'(.+)\',\'$crop\'/;

                                         if ($planned_plntg_num ne $planted_plntg_num ) { 
                                                 print WARN "Warning! planned ($planned_plntg_num) and actual ($planted_plntg_num) plantings differ for $row, $packet, $ma x $pa!\n"; 
                                                 $planted_plntg_num = "*!";
                                                 }

                                         $plan =~ s/\'//g;
				         }
			          }
	 	 
	 	 
                          else { print WARN "Warning! no ma and pa for row $row planted with packet $packet!\n"; }
	 	 
                          print RES "$row  $knum   $family   $ma x $pa\n$packet  $genotype\n$planted_plntg_num\t$plan\n\t$comment\n\n";

                          if ( $plan ne "[observe]" ) { 
                                  ($plan) = $plan =~ /\[(.+)\]/;
                                  $plan =~ s/self/\@/;
                                  $plan =~ s/observe//g;
                                  $plan =~ s/,$//;
                                  ($prow) = $row =~ /r00(\d{3})/;
                                  print PLAN "$prow,\"$plan\"\n";
			          }
                  	 	 
                          $ma = "";
                          $pa = "";
                          $maline = "";
                          $match_index = "";
                          $family = "";
                          $tmp = "";
                          $genotype = "";
                          $knum = "";
                          $planline = "";
                          $planned_plntg_num = "";
                          $plan = "";
                          $comment = "";
                          $prow = "";
		          }

                 $ppline = "";
                 $packet = "";
                 $date = "";
                 $planted_plntg_num = "";
	         }


         else { print WARN "Warning! row $row not planted in crop $crop!\n"; }

         $plline = "";
         $row = "";
         }

close(RES);
close(WARN);
close(PLAN);







######## subroutines ##########


sub make_plantings_hash {
        ($crop,$crop_file) = @_;


        open(CROP,"<$crop_file") || die "can't open $crop_file\n";

        while (<CROP>) {

                if ( $_ =~ /$crop/ ) {
                        ($plntg,$date) = $_ =~ /,(\d),(${prolog_date_re}),/;
                        $plantings{$date} = $plntg; 
                        }
                }

        close(CROP);
        return(%plantings);
        }




# assumes less than 1000 rows!

sub make_row_array {
        ($start_row,$end_row) = @_;

        ($start_row_num) = $start_row =~ /r00(\d{3})/;
        ($end_row_num) = $end_row =~ /r00(\d{3})/;

        for ( $i = $start_row_num; $i <= $end_row_num; $i++ ) { $tmp_array[$i] = "r00" . $i; }

        @row_array = @tmp_array[$start_row_num .. $end_row_num];

        return(@row_array);
        }




