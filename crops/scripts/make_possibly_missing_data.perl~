#!/opt/perl5/perls/perl-5.26.1/bin/perl

# this is ../c/maize/label_making/make_vertical_row_stake_labels.perl

# this was ../c/maize/label_making/make_row_stake_labels.perl, now simplified a bit



# generate labels to go on the row stakes.  
#
# Warning!  We haven't tested these labels in the field yet, so we
# can't advise on the best methods for their production.  
#
# 15.4.2018 --- we now have several tested methods.
#
#
# 
# call is make_vertical_row_stake_tags.perl i NUM_ROWS 0
# (second argument, the NUM_CUTTING_TEMPLATES, is obsolete here but overloaded
# to allow for easy generation of replacement labels).
#
# Kazic, 13.11.2007
#
# for replacement vertical labels, call is make_vertical_row_stake_labels.perl i r
# have to rewrite the array of replacement labels as needed
#
# Kazic, 5.5.2011


# tested post-port, works
#
# Kazic, 17.4.2018


# shift to the 1 x 2 5/8 inch Avery tags; 30-up
#
# Kazic, 29.4.2008


# wooden stakes with vertical layout now extensively tested; labels laminated and caulked or
# epoxied onto stakes.  Caulking less permanent, 5' epoxy more so.
#
# Kazic, 1.11.2009


# switched to horizontal layout for the new wire row stakes; previous subroutines
# had "vertical" instead of "horizontal"
#
# Kazic, 23.3.2010


# with the advent of printing the labels on plastic and stapling these to the
# wooden stakes, we need to shift back to vertical labels.  Since the sheets
# are undivided 8.5 x 11 inches, and we need 4 ish x 1 inch labels, we could 
# in principle get 22 labels/sheet.  In practice, we allow for print margins
# all around, so that we get 20 labels/sheet, ensuring that nothing is printed
# within 0.5 inch of any margin.
#
# Kazic, 12.5.2014




use strict;
use warnings;


use lib './Typesetting/';

use DefaultOrgztn;
use OrganizeData;
use TypesetGenetics;
use TypesettingMisc;
use GenerateOutput;


my $crop = $ARGV[0];
my $num_rows = $ARGV[1];
my $num_cutting = $ARGV[2];



# array of labels needed now in $input_file, which lives in 
# ../crops/inventory/management.  Each row on a single line,
# no commas or array machinery.
#
# Kazic, 22.5.2014

# $input_stem = "replacemt_rows";
my $input_stem = "18r_stakes.csv";
my $input_file = $input_dir . $input_stem;

my @labels_needed;
my @labels;


my $file_stem = "row_stake_labels"; 
my $output = $output_dir . $file_stem . $tex_suffix;



open my $in, '<', $input_file or die "can't open $input_file\n";
while (<$in>) {
        chomp($_);
        push(@labels_needed,$_);
        }









# this part is the same, no matter if the label is vertical or horizontal,
# as we are just generating the record for label layout.
#
# Kazic, 12.5.2014


if ( $num_rows =~ /\d+/ ) { (@labels) = &make_row_stake_labels($num_rows); }

elsif ( $num_rows =~ /^r$/ ) { (@labels) = &make_replacement_row_stake_labels($#labels_needed,\@labels_needed); }







# still prefer global variables!
#
# Kazic, 18.4.2018


open TAG, '>', $output or die "can't open $output\n";


&begin_row_stake_latex_file(\*TAG);





# vertical-specific calls

my ($i,$barcode_out,$row_num);

if ( $num_rows =~ /^r$/ ) {

        for ( $i = 0; $i <= $#labels; $i++ ) {
                ($barcode_out,$row_num) = split(/::/,$labels[$i]);
                &print_vertical_row_stake_label(\*TAG,$barcode_out,$row_num,$i,$#labels);
                }
        }

else {

        for ( $i = 0; $i <= $num_rows - 1; $i++ ) {
                ($barcode_out,$row_num) = split(/::/,$labels[$i]);
                &print_vertical_row_stake_label(\*TAG,$barcode_out,$row_num,$i,$num_rows);
                }
        }



&end_latex_file(\*TAG);










# latex whines about a use of \raise in vertical mode, just push
# r at the latex prompt to enter \nonstopmode

&generate_pdf($output_dir,$file_stem,$ps_suffix,$pdf_suffix);
