#!/usr/bin/perl

# this is /athe/c/maize/crops/add_reinventoried_corn_if_absent.perl
#
# We now have a modified inventory and a new list of inventory_amendmts.
# The new inventory_amendmts contains brand-new corn and corn that somehow
# wasn't put in the inventory.
#
# We also have the file of manually reinventoried corn that Avi collected when the tags 
# were replaced.  Some of these were migrated incorrectly, however.
#
#
# So now we want to make sure the amended corn makes it in correctly.
#
# How?
#
# Pass through all existing comments and newlines.
#
#
# Look at each pair of parents in the current file of inventoried corn,
# whether the parents are current or have been fixed and commented out.
#
# cases:
#
#     if the parents are current and in reinventoried, and absent from
#     amendmts: 
#            compare current inventory sleeve and amount to reinventoried:
#                   if matched, remove from reinventoried;
#                   if not matched, print both to puzzles and remove from reinventoried.
# WRITTEN
#
#
#
#     if they are present in current inventory facts but not in genotype.pl or amendmts or reinventoried:
#            do nothing to inventory, they are already in but no genotype fact has yet been issued;
#            remove from reinventoried or amendmts, or both.
#
# WRITTEN
#
#
#     if they are present in commented-out inventory facts:
#            do nothing to inventory, we fixed it already;
#            remove from reinventoried or amendmts, or both.
#
# WRITTEN
#
#
#
#     if the parents are absent in inventory but present in reinventoried and amendmts:
#            add to inventory and remove from reinventoried and amendmts.
#
#            they might not be in genotype because we can have new corn.
# 
# WRITTEN
#
#
#     if they are present in amendmts, but  absent in genotype and current inventory facts:
#            print to puzzles to think about.
#     
#     if they are absent in genotype and current inventory facts and amendmts:
#            print to puzzles to think about.
#
#
# When we find matching corn already in inventory, check for identity of sleeve and amount:
#
#     if the same, replace facts.
#     if different, print to screen to decide.


# call is perl ./add_reinventoried_corn_if_absent.perl REPLCMT_DIR_DATE OUTPUT_DIR_DATE
#
# Kelly and Kazic, 3.6.2014



use autovivification;


use lib qw(../label_making/);
use Typesetting::MaizeRegEx;
use Typesetting::DefaultOrgztn;


$repl_date = $ARGV[0];
$output_date = $ARGV[1];


$reinventoried_file = "../data/reinventory/seed_tag_replacemt/" . $repl_date . "/partial.inventory.pl";
$inventory_amendmts_file = "../data/reinventory/seed_tag_replacemt/" . $repl_date . "/inventory_amendmts";


# the new inventory file
#
$demeter_dir =~ s/\.\.\///;
$inventory_file = $demeter_dir . "safe.inventory.pl";
$genotype_file = $demeter_dir . "genotype.pl";

$out =  "../data/reinventory/seed_tag_replacemt/" . $output_date . "/possible_replaced_inventory.pl";
$leftovers = "../data/reinventory/seed_tag_replacemt/" . $output_date . "/leftovers";
$puzzles = "../data/reinventory/seed_tag_replacemt/" . $output_date . "/puzzles";

$today = `date`;
chomp($today);





open(GEN,"$genotype_file") or die "can't open genotype file $genotype_file\n";

while (<GEN>) {
        if ( $_ =~ /^genotype/ ) {
                my ($gma,$gpa) = $_ =~ /^genotype\(\d+,\d+,\'(${num_gtype_re})\',\d+,\'(${num_gtype_re})\',.+/;
                $genes{$gma} = $gpa;
                }
# else ignore
        }

close(GEN);






# the %amends is indexed by the new, correct ma that matches the genotype fact; the pa also
# matches the genotype fact.  These are the parents that should be directly replaced.
#
# put in "brand new" inventory facts from $inventory_amendmts_file before by hand
#

open(AMEND,"<$inventory_amendmts_file") or die  "can't open reinventoried file $inventory_amendmts_file\n";
$amends_hash = {};

while (<AMEND>) {
        my ($ama,$apa) = $_ =~ /^new (${num_gtype_re}) x (${num_gtype_re})/;
        $amends{$ama} = $apa;
        }

close(AMEND);





# the partial inventory file is opened and a hash of its parts generated.

open(REINV,"<$reinventoried_file") or die "can't open reinventoried corn file $reinventoried_file\n";
$reinv_hash = {};

while (<REINV>) {
        if ( $_ =~ /^inventory/ ) {
                my ($reifront,$reima,$reimid,$reipa,$reirest) = $_ =~ /^(inventory\(\')(${num_gtype_re})(\',\')(${num_gtype_re})(.+)/;
                $reinv{$reima} = $reipa . "::" . $reifront . "::" . $reimid . "::" . $reirest;
	        }
# else, ignore
        }

close(REINV);







# the new inventory file gets opened twice: once to build its hashes, and
# once to generate the output inventory file by the logic above.
#
# I inserted an extra space between % and inventory for comments that I don't want to process.
# There were two of these.

open(INV,"<$inventory_file") or die "can't open the current inventory file $inventory_file\n";

while (<INV>) {
        if ( $_ =~ /^inventory/ ) {
                my ($curr_front,$curr_ima,$curr_mid,$curr_ipa,$curr_rest) = $_ =~ /^(inventory\(\')(${num_gtype_re})(\',\')(${num_gtype_re})(.+)/;
                $curr_inv{$curr_ima} = $curr_ipa . "::" . $curr_front . "::" . $curr_mid . "::" . $curr_rest;
	        }

        elsif ( $_ =~ /^% inventory/ ) {
                my ($bogus_front,$bogus_ima,$bogus_mid,$bogus_ipa,$bogus_rest) = $_ =~ /^(inventory\(\')(${num_gtype_re})(\',\')(${num_gtype_re})(.+)/;
                $bogus_inv{$bogus_ima} = $bogus_ipa . "::" . $bogus_front . "::" . $bogus_mid . "::" . $bogus_rest;
	        }
        }

close(INV);








open(INV,"<$inventory_file") or die "can't open the current inventory file $inventory_file\n";
open(OUT,">$out") or die "can't open the output inventory file $out\n";
open(PUZ,">$puzzles") or die "can't open the output puzzles file $puzzles\n";




print OUT "% this is $out\n%\n% the file of inventory facts that have been reconciled to\n% reinventoried corn $reinventoried_file\n% and inventory amendments $inventory_amendmts_file.\n%\n% Generated on $today by\n% /athe/c/maize/crops/add_reinventoried_corn_if_absent.perl.\n%\n";
print OUT "% Each replacement is commented out locally with a note about the replacement method.\n%\n% Previous data otherwise copied over directly.\n\n\n\n\n";

print PUZ "% this is $puzzles\n%\n% the file of inventory facts that don't fit any cases\n% and that we have look at manually.\n%\n% Generated on $today by\n% /athe/c/maize/crops/add_reinventoried_corn_if_absent.perl.\n%\n";


# crib sheet of hashes and files
#
# genotype parents are in %genes{MA} = PA
#
# amendmt parents are in %amends{MA} = PA
# hash ref is $amends_hash
#
# reinventoried parents are in %reinv{MA} = PA :: FRONT :: MID :: REST
# hash ref is $reinv_hash
#
# current inventory parents are in %curr_inv{MA} = PA :: FRONT :: MID :: REST
# bogus inventory parents are in %bogus_inv{MA} = PA :: FRONT :: MID :: REST
#
# OUT is new modified inventory file
# LEFT is remainders of %amends and %reinv after substitutions have been removed
# PUZ is everything else






# in the inventory file, we have comments, current facts, and bogus facts that were replaced.
#
# For each line, look at it and do the right thing.


while (<INV>) {


# want to preserve all comments, etc.

        if ( ( $_ !~ /^inventory/ ) || ( $_ !~ /^% inventory/ ) ) { print OUT $_; }


# look at current inventory facts

        elsif ( $_ =~ /^inventory/ )  {

                my ($front,$ima,$mid,$ipa,$rest) = $_ =~ /^(inventory\(\')(${num_gtype_re})(\',\')(${num_gtype_re})(.+)/;
#                print "$front,$ima,$mid,$ipa,$rest\n";

                if ( exists $reinv{$ima} ) {
                        $reinved = $reinv{$ima};
                        ($reinvipa,$reinvfront,$reinvmid,$reinvrest) = split("::",$reinved);

                        if ( $ipa eq $reinvipa ) {
                                my $use_or_no = &decide_curr_vs_reinv(\*OUT,$ima,$ipa,$front,$mid,$rest,$reinvrest);
                                delete $reinv_hash->{$ima};
                                if ( $use_or_no == 0 ) { print PUZ "($ima,$ipa,$rest,$reinvrest)\n"; }


# also delete the pair if present in amendments

                         	if ( exists $amends{$ima} ) { delete $amends_hash->{$ima}; }
			        }
		        }
                        else { print "mismatch bwtn current inventory $ima x $ipa and reinventoried $ima x $reinvipa!\n"; }



# if current and not in reinventoried and amendmts, then it's ok!

                else { print OUT $front . $ima . $mid . $ipa . $rest . "\n"; }
	        }
                
	elsif ( $_ =~ /^% inventory / ) {

                my ($bogus_front,$bogus_ima,$bogus_mid,$bogus_ipa,$bogus_rest) = $_ =~ /^(inventory\(\')(${num_gtype_re})(\',\')(${num_gtype_re})(.+)/;

                if ( exists $reinv{$bogus_ima} ) { delete $reinv_hash->{$bogus_ima}; }

                if ( exists $amends{$bogus_ima} ) { delete $amends_hash->{$bogus_ima}; }                         

                }
        }

close(INV);


# now we search for real facts that haven't made it into inventory yet.

print OUT "\n\n\n% facts found in reinventoried and amendments, but not yet in inventory.\n% inserted by /athe/c/maize/crops/add_reinventoried_corn_if_absent.perl.\n% on $today.\n\n\n";

foreach $rema ( sort ( keys %reinv ) ) {

        $rereinved = $reinv{$ima};
        ($rereinvipa,$rereinvfront,$rereinvmid,$rereinvrest) = split("::",$rereinved);


        if ( ( exists $amends{$rema} ) && ( $rereinvipa eq $amends{$rema} ) ) { 
                 print OUT $rereinvfront . $rema . $rereinvmid . $rereinvipa . $rereinvrest . "\n";
                 delete $reinv_hash->{$rema}; 
                 delete $amends_hash->{$rema};
                 }
        }


# now it's safe to close OUT

close(OUT);






# now we deal with leftover reinv and puzzles


# print the remainder of the reinventory to LEFT

open(LEFT,">$leftovers") or die "can't open the output leftovers file $leftovers\n";
print LEFT "% this is $leftovers\n%\n% the file of inventory facts that were not reconciled to\n% between reinventoried cornn $reinventoried_file\n% and inventory amendments $inventory_amendmts_file and\n% inventory file $inventory_file.\n%\n% Generated on $today by\n% /athe/c/maize/crops/add_reinventoried_corn_if_absent.perl.\n%\n\n\n";

foreach $lema ( sort ( keys %reinv ) ) {

        $leinved = $reinv{$lema};
        ($leinvipa,$leinvfront,$leinvmid,$leinvrest) = split("::",$leinved);
        print LEFT $leinvfront . $lema . $leinvmid . $leinvipa . $leinvrest . "\n";
        }

close(LEFT);







# print any leftover amendments to puzzles

print PUZ "% here are the remaining puzzles from leftover amends\n\n\n";

foreach $ama ( sort ( keys %amends ) ) {

        $apa = $amends{$ama};
        ($leinvipa,$leinvfront,$leinvmid,$leinvrest) = split("::",$leinved);
        print PUZ "$ama x $apa\n";
        }

close(PUZ);











sub decide_curr_vs_reinv {

        ($filehandle,$ima,$ipa,$front,$mid,$rest,$reinvrest) = @_;

        if ( $rest eq $reinvrest ) { 
                print $filehandle $front . $ima . $mid . $ipa . $rest . "\n"; 
                $use_or_no = 1;
                }

        else { 

                ($num_cl,$middle,$sleeve,$end) = $rest =~ /(,num_kernels\([\w_]+\))(.+)(${sleeve_re})(.+)$/;
                ($renum_cl,$remiddle,$resleeve,$reend) = $reinvrest =~ /(,num_kernels\([\w_]+\))(.+)(${sleeve_re})(.+)$/;

                print "($num_cl,$middle,$sleeve,$end)\n";

                if ( $sleeve eq $resleeve ) {

                        if ( $num_cl eq $renum_cl) { print $filehandle $front . $ima . $mid . $ipa . $num_cl . $remiddle . $sleeve . $reend . "\n";}
                        else { print $filehandle $front . $ima . $mid . $ipa . $renum_cl . $remiddle . $sleeve . $reend . "\n";}
                        $use_or_no = 1;
                        }


                elsif ( $sleeve ne $resleeve ) {

                        if ( $num_cl eq $renum_cl ) { print $filehandle $front . $ima . $mid . $ipa . $num_cl . $remiddle . $resleeve . $reend . "\n";}
                        else { print $filehandle $front . $ima . $mid . $ipa . $renum_cl . $remiddle . $resleeve . $reend . "\n";}
                        $use_or_no = 1;
                        }


                else { $use_or_no = 0; }
	        }
        }





# if ok to print to OUT, the $use_or_no = 1
# otherwise set to 0
# in either case return

        return $use_or_no;
        }
