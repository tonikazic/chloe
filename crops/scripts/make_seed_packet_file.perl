#!/opt/perl5/perls/perl-5.26.1/bin/perl



# this is ../c/maize/crops/scripts/make_seed_packet_file.perl 

# If we don't have any prolog, we still need to generate the seed_packet_labels
# file from sequenced.packing_plan.pl.  So this script does that.
#
# 
# call is perl ./make_seed_packet_file.perl CROP
#
# Kazic, 23.5.2017



# converted to run in perl 5.26
#
# Kazic, 13.6.2018


use strict;
use warnings;

use Cwd 'getcwd';



use lib '../../label_making/Typesetting/';
use DefaultOrgztn;
use MaizeRegEx;




# our $crop = $ARGV[0]; in DefaultOrgztn


my $local_dir = getcwd;
my ($dir) = &adjust_paths($crop,$local_dir);

my $uccrop = uc($crop);



my $today = `date`;
chomp($today);


my %inbred;



my $input_file = $dir . $planning_root . "sequenced.packing_plan.pl";
my $out_file = $input_dir . "seed_packet_labels";
my $inbred_file = $demeter_dir . "current_inbred.pl";

# print "i: $input_file\no: $out_file\nd: $inbred_file\n";







# get the family numbers for the current inbreds.

open my $inbred_fh, '<', $inbred_file or die "sorry, can't open input file $inbred_file\n";



while (<$inbred_fh>) {
        if ( $_ =~ /$uccrop/ ) { 
	        my ($ima,$cur,$packet) = $_ =~ /\',(\d{3}),\d{3},(\d{3}),(p\d{5})\).$/;
#                print "($ima,$cur,$packet)\n";
                $inbred{$ima} = $cur . "::" . $packet;
                }
        }








# should read the inventory file and supply the sleeves for the final output
#
# Kazic, 1.6.2019






open my $in, '<', $input_file or die "sorry, can't open input file $input_file\n";
open my $out, '>', $out_file or die "can't open $out_file\n";



print $out "% this is $out_file
% generated by ../maize/crops/make_seed_packet_file.perl
% on $today for crop $crop.
%
% This file does not have the packets in inventory order!
% Re-ordering must be done manually before generating the labels!
% \n\n\n";





my $p = 10;

while (<$in>) {

        if ( $_ =~ /^packing_plan/ ) {
	        my ($row,$num_packets,$elite,$planting,$rest,$ma,$pa,$cl,$ft,$family,$pnum,$padding,$packet,$ma_ifam,$record);

#		print $_;
		
                if ( $_ =~ /elite/ ) { 
		        ($row,$num_packets,$elite,$planting,$rest) = $_ =~ /^packing_plan\((\d+),(\d+),\[(elite)\],(${planting_re}),(.*)/; 
		        $ma = $elite;
		        $pa = $ma;
                        }

		
                else {
                        ($row,$num_packets,$ma,$pa,$planting,$rest) = $_ =~ /^packing_plan\((\d+),(\d+),\[\'(${num_gtype_re})\'?[,x\s\']+(${num_gtype_re})\'\],(${planting_re}),(.*)/; 
		        }



                ($cl,$ft) = $rest =~ /(${cl_re}),(${ft_re})\)\.$/;



		
		
# family and packet assignment

# included condition to prevent individual numbering of elite corn packets
#
# Kazic, 2.6.2019

		if ( ( $ma !~ /xxxx/ ) && ( $ma !~ /elite/ ) ) { 
                        $family = '0000'; 
                        $pnum = length($p);
			$padding = 5 - $pnum;
			$packet = "p" . "0" x $padding . $p;
			$p++;
		        }
		
                elsif ( $ma =~ /\d{2}[NRG](\d{3})\:/ ) {
			($ma_ifam) = $ma =~ /\d{2}[NRG](\d{3})\:/;
			$record = $inbred{$ma_ifam};
		        ($family,$packet) = split(/::/,$record);
		        }


		
# ugly hard-wired kludge for the elite corn for now
#
# Kazic, 1.6.2019
			
		else {
			$record = $inbred{891};
		        ($family,$packet) = split(/::/,$record);
		        }

                
		
#                print "($row,$num_packets,$ma,$pa,$planting,$cl,$ft,$family,$packet)\n";



		
# now after all this, print the re-arranged line to the output file
#
# someday, get the sleeve correctly from the inventory data
#
# Kazic, 10.7.2018

		print $out "$packet,$family,$ma,$pa,$cl,$ft,v00,$num_packets,$row,$planting\n";
	        }
	}


